//{
//        "code": null,
//        "message": null,
//        "plugin_name": null,
//        "plugin_observation": {
//        "natural_language_desc": "\n蓝桥杯JAVA-14.连续最大子数组模板\n蓝桥杯JAVA-14.连续最大子数组模板\n分类专栏：\n                                蓝桥杯\n                            文章标签：\n                                蓝桥杯\n                                java\n                                动态规划\n目录\n分为连续子数组和非连续子数组，在一维的情况下可以等同于字串和子序列的最大和。\n连续子数组\n对于一个数A[ i ]，若是A[ i ] 的左边累计数非负，那么加上A[ i ] 能使得值不小于A[ i ]，认为累计值对整体和是有贡献的。如果前几项累计值负数，则认为有害于总和。\n一维\n动态规划：算法时间复杂度：O(n)\n对于一个数A[ i ]，若是A[ i ] 的左边累计数非负，那么加上A[ i ] 能使得值不小于A[ i ]，认为累计值对整体和是有贡献的。如果前几项累计值负数，则认为有害于总和，应丢弃。\ndp[ i ]表示以a[ i ]结尾的「连续子数组的最大和」，不是整个数组的最大子数组和。\n即：dp[ i ] = max{dp[ i-1 ] + a[ i ]，a[ i ] }；\n初始状态：dp[0] = a[0];\nimport java.io.*;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\n\n\n/**\n * @Author DragonOne\n * @Date 2021/12/5 21:27\n * @墨水记忆 www.tothefor.com\n */\npublic class Main {\n    public static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    public static BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\n    public static StreamTokenizer cin = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    public static PrintWriter cout = new PrintWriter(new OutputStreamWriter(System.out));\n    public static Scanner sc = new Scanner(System.in);\n\n    public static int maxd = 200000+7;\n    public static int INF = 0x3f3f3f3f;\n    public static int mod = 998244353;\n\n\n    public static void main(String[] args) throws Exception {\n\n        int n = nextInt();\n        int[] a = new int[maxd];\n        int[] dp = new int[maxd]; //dp[i]表示以a[i]结尾的「连续子数组的最大和」\n        for(int i=1;i<=n;++i) a[i] = nextInt();\n        int ans = a[1]; //ans用来存储最后的答案\n        dp[1]=a[1]; //初始化第一个数默认是它自己\n        for(int i=1;i<=n;++i){ //如果a数组是从0开始存的，这里必须从第二个数开始，否则会存在下标为 0-1=-1 的情况.而现在这里从1或2开始都行\n            dp[i]=Math.max(dp[i-1]+a[i],a[i]);\n            ans=Math.max(ans,dp[i]);\n        }\n        System.out.println(ans);\n        closeAll();\n    }\n\n    public static void cinInit(){\n        cin.wordChars('a', 'z');\n        cin.wordChars('A', 'Z');\n        cin.wordChars(128 + 32, 255);\n        cin.whitespaceChars(0, ' ');\n        cin.commentChar('/');\n        cin.quoteChar('\"');\n        cin.quoteChar('\\'');\n        cin.parseNumbers();\n    }\n    public static int nextInt() throws Exception {\n        cin.nextToken();\n        return (int) cin.nval;\n    }\n    public static long nextLong() throws Exception {\n        cin.nextToken();\n        return (long) cin.nval;\n    }\n    public static double nextDouble() throws Exception {\n        cin.nextToken();\n        return cin.nval;\n    }\n    public static String nextString() throws Exception {\n        cin.nextToken();\n        return cin.sval;\n    }\n    public static void closeAll() throws Exception {\n        cout.close();\n        in.close();\n        out.close();\n    }\n}\n测试数据：\n//输入\n9\n-2 1 -3 4 -1 2 1 -5 4\n\n//输出    \n6\n滚动数组（空间优化）\n因为，dp[ i ] 只与dp[ i-1] 有关，所以可以用一个变量 midsum 来维护对于当前 dp[ i ]的dp[ i-1 ] 的值是多少，从而让空间复杂度降低到 O(1)，这类似「滚动数组」的思想。\nimport java.io.*;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\n\n\n/**\n * @Author DragonOne\n * @Date 2021/12/5 21:27\n * @墨水记忆 www.tothefor.com\n */\npublic class Main {\n    public static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    public static BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\n    public static StreamTokenizer cin = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    public static PrintWriter cout = new PrintWriter(new OutputStreamWriter(System.out));\n    public static Scanner sc = new Scanner(System.in);\n\n    public static int maxd = 200000+7;\n    public static int INF = 0x3f3f3f3f;\n    public static int mod = 998244353;\n\n    public static void main(String[] args) throws Exception {\n\n        int n = nextInt();\n        int[] a = new int[100]; //原数组\n        for(int i=1;i<=n;++i) a[i] = nextInt();\n        int midsum = a[1]; //初始化\n        int ans = a[1]; //默认答案为第一个数\n        for(int i=1;i<=n;++i){\n            midsum=Math.max(midsum+a[i],a[i]);\n            ans=Math.max(ans,midsum);\n        }\n        System.out.println(ans);\n        closeAll();\n    }\n\n    public static void cinInit(){\n        cin.wordChars('a', 'z');\n        cin.wordChars('A', 'Z');\n        cin.wordChars(128 + 32, 255);\n        cin.whitespaceChars(0, ' ');\n        cin.commentChar('/');\n        cin.quoteChar('\"');\n        cin.quoteChar('\\'');\n        cin.parseNumbers();\n    }\n    public static int nextInt() throws Exception {\n        cin.nextToken();\n        return (int) cin.nval;\n    }\n    public static long nextLong() throws Exception {\n        cin.nextToken();\n        return (long) cin.nval;\n    }\n    public static double nextDouble() throws Exception {\n        cin.nextToken();\n        return cin.nval;\n    }\n    public static String nextString() throws Exception {\n        cin.nextToken();\n        return cin.sval;\n    }\n    public static void closeAll() throws Exception {\n        cout.close();\n        in.close();\n        out.close();\n    }\n}\n二维\n将二维转化为一维数组计算，然后计算一维的最大子数组问题。\n方法：将每一列求一个前缀和，得到一个一维数组。\n时间复杂度：O(n*n*m)\n矩阵转置\n看网上的一些说明，当行大于列时进行转置（因为遍历的时候是遍历的行，所以找行、列中的较小值作为行可以减少遍历次数），但感觉根本没用，因为后面求的时候行和列都用到了，时间复杂度根本没变。但是这里也写上吧。\npublic static int[][] Matreverse(int[][] a,int m,int n) { //m行n列的数组a，a数组下标从1开始\n    int[][] newArr = new int[n+5][m+5]; //转化后的n行m列数组\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            newArr[j][i] = a[i][j];\n        }\n    }\n    return newArr;\n}\n代码实现\n这里没有用转置。（感觉用了没用）\nimport java.io.*;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\n\n\n/**\n * @Author DragonOne\n * @Date 2021/12/5 21:27\n * @墨水记忆 www.tothefor.com\n */\npublic class Main {\n    public static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    public static BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\n    public static StreamTokenizer cin = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    public static PrintWriter cout = new PrintWriter(new OutputStreamWriter(System.out));\n    public static Scanner sc = new Scanner(System.in);\n\n    public static int maxd = 200000+7;\n    public static int INF = 0x3f3f3f3f;\n    public static int mod = 998244353;\n\n    //求一维数组的最大子数组\n    public static int getOne(int[]a,int n){ //n为长度，a数组是下标从1开始存储的\n        int[] dp = new int[maxd]; //dp[i]表示以a[i]结尾的「连续子数组的最大和」\n        int ans = a[1]; //ans用来存储最后的答案\n        dp[1]=a[1]; //初始化第一个数默认是它自己\n        for(int i=1;i<=n;++i){ //如果a数组是从0开始存的，这里必须从第二个数开始，否则会存在下标为 0-1=-1 的情况.而现在这里从1或2开始都行\n            dp[i]=Math.max(dp[i-1]+a[i],a[i]);\n            ans=Math.max(ans,dp[i]);\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) throws Exception {\n\n        int n = nextInt(); //行\n        int m = nextInt(); //列\n        int[][] a = new int[100][100]; //原数组\n        for(int i=1;i<=n;++i){\n            for(int j=1;j<=m;++j){\n                a[i][j] = nextInt();\n            }\n        }\n        //求每一列的前缀和，每一列中从第一行到第i行的和\n        int[][] p = new int[105][105]; //p[i][j]表示j这一列的前i个数的和\n        for(int i=1;i<=n;++i){\n            for(int j=1;j<=m;++j){\n                p[i][j]=p[i-1][j]+a[i][j];\n            }\n        }\n\n        int maxans = 0;\n        for(int i=1;i<=n;++i){ //第i行\n            for(int j=i;j<=n;++j){ //到最后一行\n                maxans=Math.max(maxans,getOne(p[i],m));\n            }\n        }\n        System.out.println(maxans);\n\n        closeAll();\n    }\n\n    public static void cinInit(){\n        cin.wordChars('a', 'z');\n        cin.wordChars('A', 'Z');\n        cin.wordChars(128 + 32, 255);\n        cin.whitespaceChars(0, ' ');\n        cin.commentChar('/');\n        cin.quoteChar('\"');\n        cin.quoteChar('\\'');\n        cin.parseNumbers();\n    }\n    public static int nextInt() throws Exception {\n        cin.nextToken();\n        return (int) cin.nval;\n    }\n    public static long nextLong() throws Exception {\n        cin.nextToken();\n        return (long) cin.nval;\n    }\n    public static double nextDouble() throws Exception {\n        cin.nextToken();\n        return cin.nval;\n    }\n    public static String nextString() throws Exception {\n        cin.nextToken();\n        return cin.sval;\n    }\n    public static void closeAll() throws Exception {\n        cout.close();\n        in.close();\n        out.close();\n    }\n}\n测试数据：\n//输入\n2 3\n1 2 3\n3 -1 4\n\n//输出\n12\n\n",
//        "observation": "{\"data\":{\"title\":\"蓝桥杯JAVA-14.连续最大子数组模板\",\"content\":\"蓝桥杯JAVA-14.连续最大子数组模板\\n分类专栏：\\n                                蓝桥杯\\n                            文章标签：\\n                                蓝桥杯\\n                                java\\n                                动态规划\\n目录\\n分为连续子数组和非连续子数组，在一维的情况下可以等同于字串和子序列的最大和。\\n连续子数组\\n对于一个数A[ i ]，若是A[ i ] 的左边累计数非负，那么加上A[ i ] 能使得值不小于A[ i ]，认为累计值对整体和是有贡献的。如果前几项累计值负数，则认为有害于总和。\\n一维\\n动态规划：算法时间复杂度：O(n)\\n对于一个数A[ i ]，若是A[ i ] 的左边累计数非负，那么加上A[ i ] 能使得值不小于A[ i ]，认为累计值对整体和是有贡献的。如果前几项累计值负数，则认为有害于总和，应丢弃。\\ndp[ i ]表示以a[ i ]结尾的「连续子数组的最大和」，不是整个数组的最大子数组和。\\n即：dp[ i ] = max{dp[ i-1 ] + a[ i ]，a[ i ] }；\\n初始状态：dp[0] = a[0];\\nimport java.io.*;\\nimport java.text.SimpleDateFormat;\\nimport java.util.*;\\n\\n\\n/**\\n * @Author DragonOne\\n * @Date 2021/12/5 21:27\\n * @墨水记忆 www.tothefor.com\\n */\\npublic class Main {\\n    public static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\\n    public static BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\\n    public static StreamTokenizer cin = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\\n    public static PrintWriter cout = new PrintWriter(new OutputStreamWriter(System.out));\\n    public static Scanner sc = new Scanner(System.in);\\n\\n    public static int maxd = 200000+7;\\n    public static int INF = 0x3f3f3f3f;\\n    public static int mod = 998244353;\\n\\n\\n    public static void main(String[] args) throws Exception {\\n\\n        int n = nextInt();\\n        int[] a = new int[maxd];\\n        int[] dp = new int[maxd]; //dp[i]表示以a[i]结尾的「连续子数组的最大和」\\n        for(int i=1;i<=n;++i) a[i] = nextInt();\\n        int ans = a[1]; //ans用来存储最后的答案\\n        dp[1]=a[1]; //初始化第一个数默认是它自己\\n        for(int i=1;i<=n;++i){ //如果a数组是从0开始存的，这里必须从第二个数开始，否则会存在下标为 0-1=-1 的情况.而现在这里从1或2开始都行\\n            dp[i]=Math.max(dp[i-1]+a[i],a[i]);\\n            ans=Math.max(ans,dp[i]);\\n        }\\n        System.out.println(ans);\\n        closeAll();\\n    }\\n\\n    public static void cinInit(){\\n        cin.wordChars('a', 'z');\\n        cin.wordChars('A', 'Z');\\n        cin.wordChars(128 + 32, 255);\\n        cin.whitespaceChars(0, ' ');\\n        cin.commentChar('/');\\n        cin.quoteChar('\\\"');\\n        cin.quoteChar('\\\\'');\\n        cin.parseNumbers();\\n    }\\n    public static int nextInt() throws Exception {\\n        cin.nextToken();\\n        return (int) cin.nval;\\n    }\\n    public static long nextLong() throws Exception {\\n        cin.nextToken();\\n        return (long) cin.nval;\\n    }\\n    public static double nextDouble() throws Exception {\\n        cin.nextToken();\\n        return cin.nval;\\n    }\\n    public static String nextString() throws Exception {\\n        cin.nextToken();\\n        return cin.sval;\\n    }\\n    public static void closeAll() throws Exception {\\n        cout.close();\\n        in.close();\\n        out.close();\\n    }\\n}\\n测试数据：\\n//输入\\n9\\n-2 1 -3 4 -1 2 1 -5 4\\n\\n//输出    \\n6\\n滚动数组（空间优化）\\n因为，dp[ i ] 只与dp[ i-1] 有关，所以可以用一个变量 midsum 来维护对于当前 dp[ i ]的dp[ i-1 ] 的值是多少，从而让空间复杂度降低到 O(1)，这类似「滚动数组」的思想。\\nimport java.io.*;\\nimport java.text.SimpleDateFormat;\\nimport java.util.*;\\n\\n\\n/**\\n * @Author DragonOne\\n * @Date 2021/12/5 21:27\\n * @墨水记忆 www.tothefor.com\\n */\\npublic class Main {\\n    public static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\\n    public static BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\\n    public static StreamTokenizer cin = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\\n    public static PrintWriter cout = new PrintWriter(new OutputStreamWriter(System.out));\\n    public static Scanner sc = new Scanner(System.in);\\n\\n    public static int maxd = 200000+7;\\n    public static int INF = 0x3f3f3f3f;\\n    public static int mod = 998244353;\\n\\n    public static void main(String[] args) throws Exception {\\n\\n        int n = nextInt();\\n        int[] a = new int[100]; //原数组\\n        for(int i=1;i<=n;++i) a[i] = nextInt();\\n        int midsum = a[1]; //初始化\\n        int ans = a[1]; //默认答案为第一个数\\n        for(int i=1;i<=n;++i){\\n            midsum=Math.max(midsum+a[i],a[i]);\\n            ans=Math.max(ans,midsum);\\n        }\\n        System.out.println(ans);\\n        closeAll();\\n    }\\n\\n    public static void cinInit(){\\n        cin.wordChars('a', 'z');\\n        cin.wordChars('A', 'Z');\\n        cin.wordChars(128 + 32, 255);\\n        cin.whitespaceChars(0, ' ');\\n        cin.commentChar('/');\\n        cin.quoteChar('\\\"');\\n        cin.quoteChar('\\\\'');\\n        cin.parseNumbers();\\n    }\\n    public static int nextInt() throws Exception {\\n        cin.nextToken();\\n        return (int) cin.nval;\\n    }\\n    public static long nextLong() throws Exception {\\n        cin.nextToken();\\n        return (long) cin.nval;\\n    }\\n    public static double nextDouble() throws Exception {\\n        cin.nextToken();\\n        return cin.nval;\\n    }\\n    public static String nextString() throws Exception {\\n        cin.nextToken();\\n        return cin.sval;\\n    }\\n    public static void closeAll() throws Exception {\\n        cout.close();\\n        in.close();\\n        out.close();\\n    }\\n}\\n二维\\n将二维转化为一维数组计算，然后计算一维的最大子数组问题。\\n方法：将每一列求一个前缀和，得到一个一维数组。\\n时间复杂度：O(n*n*m)\\n矩阵转置\\n看网上的一些说明，当行大于列时进行转置（因为遍历的时候是遍历的行，所以找行、列中的较小值作为行可以减少遍历次数），但感觉根本没用，因为后面求的时候行和列都用到了，时间复杂度根本没变。但是这里也写上吧。\\npublic static int[][] Matreverse(int[][] a,int m,int n) { //m行n列的数组a，a数组下标从1开始\\n    int[][] newArr = new int[n+5][m+5]; //转化后的n行m列数组\\n    for (int i = 1; i <= m; i++) {\\n        for (int j = 1; j <= n; j++) {\\n            newArr[j][i] = a[i][j];\\n        }\\n    }\\n    return newArr;\\n}\\n代码实现\\n这里没有用转置。（感觉用了没用）\\nimport java.io.*;\\nimport java.text.SimpleDateFormat;\\nimport java.util.*;\\n\\n\\n/**\\n * @Author DragonOne\\n * @Date 2021/12/5 21:27\\n * @墨水记忆 www.tothefor.com\\n */\\npublic class Main {\\n    public static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\\n    public static BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\\n    public static StreamTokenizer cin = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\\n    public static PrintWriter cout = new PrintWriter(new OutputStreamWriter(System.out));\\n    public static Scanner sc = new Scanner(System.in);\\n\\n    public static int maxd = 200000+7;\\n    public static int INF = 0x3f3f3f3f;\\n    public static int mod = 998244353;\\n\\n    //求一维数组的最大子数组\\n    public static int getOne(int[]a,int n){ //n为长度，a数组是下标从1开始存储的\\n        int[] dp = new int[maxd]; //dp[i]表示以a[i]结尾的「连续子数组的最大和」\\n        int ans = a[1]; //ans用来存储最后的答案\\n        dp[1]=a[1]; //初始化第一个数默认是它自己\\n        for(int i=1;i<=n;++i){ //如果a数组是从0开始存的，这里必须从第二个数开始，否则会存在下标为 0-1=-1 的情况.而现在这里从1或2开始都行\\n            dp[i]=Math.max(dp[i-1]+a[i],a[i]);\\n            ans=Math.max(ans,dp[i]);\\n        }\\n        return ans;\\n    }\\n\\n    public static void main(String[] args) throws Exception {\\n\\n        int n = nextInt(); //行\\n        int m = nextInt(); //列\\n        int[][] a = new int[100][100]; //原数组\\n        for(int i=1;i<=n;++i){\\n            for(int j=1;j<=m;++j){\\n                a[i][j] = nextInt();\\n            }\\n        }\\n        //求每一列的前缀和，每一列中从第一行到第i行的和\\n        int[][] p = new int[105][105]; //p[i][j]表示j这一列的前i个数的和\\n        for(int i=1;i<=n;++i){\\n            for(int j=1;j<=m;++j){\\n                p[i][j]=p[i-1][j]+a[i][j];\\n            }\\n        }\\n\\n        int maxans = 0;\\n        for(int i=1;i<=n;++i){ //第i行\\n            for(int j=i;j<=n;++j){ //到最后一行\\n                maxans=Math.max(maxans,getOne(p[i],m));\\n            }\\n        }\\n        System.out.println(maxans);\\n\\n        closeAll();\\n    }\\n\\n    public static void cinInit(){\\n        cin.wordChars('a', 'z');\\n        cin.wordChars('A', 'Z');\\n        cin.wordChars(128 + 32, 255);\\n        cin.whitespaceChars(0, ' ');\\n        cin.commentChar('/');\\n        cin.quoteChar('\\\"');\\n        cin.quoteChar('\\\\'');\\n        cin.parseNumbers();\\n    }\\n    public static int nextInt() throws Exception {\\n        cin.nextToken();\\n        return (int) cin.nval;\\n    }\\n    public static long nextLong() throws Exception {\\n        cin.nextToken();\\n        return (long) cin.nval;\\n    }\\n    public static double nextDouble() throws Exception {\\n        cin.nextToken();\\n        return cin.nval;\\n    }\\n    public static String nextString() throws Exception {\\n        cin.nextToken();\\n        return cin.sval;\\n    }\\n    public static void closeAll() throws Exception {\\n        cout.close();\\n        in.close();\\n        out.close();\\n    }\\n}\\n测试数据：\\n//输入\\n2 3\\n1 2 3\\n3 -1 4\\n\\n//输出\\n12\\n\"},\"error_msg\":\"\",\"error_code\":\"\"}"
//        }
//        }